#version 450

#include "ATMOS.h"

layout( local_size_x = 16, local_size_y = 16 ) in;

layout( push_constant ) uniform PUSH { AtmosphereParameters params; };

layout( set = 0, binding = 0 ) uniform ViewInfo
{
   mat4 invProj;
   mat4 invView;
   vec4 viewPos;
   vec4 lightDir;
}
viewInfo;

layout( set = 0, binding = 1 ) uniform sampler2D transmittanceLUT;
layout( set = 0, binding = 2 ) uniform sampler2D skyViewLUT;
layout( set = 0, binding = 3 ) writeonly uniform image2D colorImage;
layout( set = 0, binding = 4 ) uniform sampler2D depthSampler;

vec3 jodieReinhardTonemap( vec3 c )
{
   // From: https://www.shadertoy.com/view/tdSXzD
   float l = dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );
   vec3 tc = c / ( c + 1.0 );
   return mix( c / ( l + 1.0 ), tc, tc );
}

const float sunMaxAngle = 2.5;  // 2.5 degrees

vec3 getSunLuminance(
    AtmosphereParameters params,
    vec3 rayDir,
    vec3 sunDir,
    vec3 viewPos,
    float height )
{
   // If part of the sun is below ground level, some of it is hidden
   const float groundDist = rayIntersectSphere( viewPos, rayDir, spherePos, params.groundRadiusMM );
   const float groundFactor = groundDist >= 0.0 ? 0.0 : 1.0;

   const float sunCosAngle = cos( sunMaxAngle * PI / 180.0 );
   const float cosTheta    = dot( rayDir, sunDir );

   const float diff = sunCosAngle - cosTheta;

   vec3 sunLuminance = vec3( 0.0 );

   // Sun glow
   sunLuminance += groundFactor * vec3( exp( -diff * 5000.0 ) * 10.0 );

   // Sun fog
   // The higher we are in the atmosphere, the less sun fog we have
   // This probably would not be needed with the aerial perspective LUT
   const float heightRatio =
       ( height - params.groundRadiusMM ) / ( params.atmosphereRadiusMM - params.groundRadiusMM );

   const float heighFactor = exp( -5.0 * heightRatio );
   sunLuminance += heighFactor * vec3( exp( -diff * 30.0 ) * 0.05 );

   return sunLuminance;
}

// ================================================================================================
void main()
{
   const ivec2 ssCoord = ivec2( gl_GlobalInvocationID.xy );
   const vec2 uv       = vec2( ssCoord + 0.5 ) / vec2( imageSize( colorImage ) );

   // Do not write anything if there's anything in the depth
   const float depth = texture( depthSampler, uv ).r;  // From 0 to 1
   if( depth > 0.0 ) return;

   const vec3 sunDir = -viewInfo.lightDir.xyz;

   // Constructing camera ray direction in world space
   // =============================================================================================
   const vec4 ndcCoord = vec4( ( uv.xy * 2.0 ) - 1.0, -1.0, 1.0 );  // UV [0,1] to NDC [-1,1]
   vec4 rayEye         = viewInfo.invProj * ndcCoord;
   rayEye.w            = 0.0;
   const vec3 rayDir   = normalize( ( viewInfo.invView * rayEye ).xyz );

   // Sampling from sky view LUT
   // =============================================================================================
   const vec3 viewPos = getMMPosition( params, viewInfo.viewPos.xyz );
   const float height = length( viewPos );

   const float beta =
       acos( sqrt( height * height - params.groundRadiusMM * params.groundRadiusMM ) / height );
   const float horizonAngle = PI - beta;

   const float altitudeAngle = horizonAngle - acos( dot( rayDir, up ) );

   const vec3 projectedDir  = normalize( rayDir - up * ( dot( rayDir, up ) ) );
   const float sinTheta     = dot( projectedDir, right );
   const float cosTheta     = dot( projectedDir, forward );
   const float azimuthAngle = atan( sinTheta, cosTheta );

   // Making UVs, Y uses non-linear mapping formula from the paper
   const vec2 lookupUV = vec2(
       azimuthAngle / ( 2.0 * PI ),
       0.5 + 0.5 * sign( altitudeAngle ) * sqrt( abs( altitudeAngle ) / ( PI * 0.5 ) ) );

   vec3 luminance = texture( skyViewLUT, lookupUV ).rgb;

   // Adding sun
   // =============================================================================================
   const vec2 transmittanceUV = LUTParameterization( params, sunDir, viewPos.xyz );
   const vec3 transmittance   = texture( transmittanceLUT, transmittanceUV ).rgb;

   const vec3 sunLuminance =
       transmittance * getSunLuminance( params, rayDir, sunDir, viewPos.xyz, height );

   luminance += sunLuminance;

   // Adjusting luminance value
   luminance *= 20.0;
   luminance = pow( luminance, vec3( 1.6 ) );
   luminance = jodieReinhardTonemap( luminance );
   luminance = pow( luminance, vec3( 1.0 / 2.2 ) );

   imageStore( colorImage, ssCoord, vec4( luminance, 1.0 ) );
}