#version 450

#include "../ATMOS.h"
#include "../NOISE.h"

layout( local_size_x = 16, local_size_y = 16 ) in;

layout( push_constant ) uniform PUSH { AtmosphereParameters params; };

layout( set = 0, binding = 0 ) uniform ViewInfo
{
   mat4 invProj;
   mat4 invView;
   vec4 viewPos;
   vec4 lightDir;
}
viewInfo;

layout( set = 0, binding = 1 ) uniform sampler2D transmittanceLUT;
layout( set = 0, binding = 2 ) uniform sampler2D skyViewLUT;
layout( set = 0, binding = 3 ) uniform sampler3D aerialPerspectiveLUT;
layout( set = 0, binding = 4, rgba32f ) uniform image2D colorImage;
layout( set = 0, binding = 5 ) uniform sampler2D depthSampler;

// Height fog top feathering noise
const NoiseParameters noiseParams = { 0.0, 1.0, 1.0, 0.25, 0.0004, 3.00, 1.0, false, false, 3 };

vec3 GetSunCircle( AtmosphereParameters params, vec3 rayDir, vec3 sunDir, vec3 viewPosMM )
{
   // If part of the sun is below ground level, some of it is hidden
   const float groundDist =
       rayIntersectSphere( viewPosMM, rayDir, spherePos, params.groundRadiusMM );
   const float groundFactor = groundDist >= 0.0 ? 0.0 : 1.0;  // Could early out

   const float cosThetaNoon = dot( sunDir, up );
   const float sunsetSize   = 0.9990;
   const float noonSize     = 0.9999;
   const float sunSize = mix( sunsetSize, noonSize, clamp( pow( cosThetaNoon, 0.3 ), 0.0, 1.0 ) );

   const float cosTheta  = dot( rayDir, sunDir );
   const float sunCircle = cosTheta > sunSize ? 1.0 : 0.0;

   const float x             = ( cosTheta - sunSize ) * 4000.0;
   const float sunFeathering = clamp( pow( x, 2 ), 0.0, 1.0 );
   const vec3 sunColor       = vec3( 1.0 );  // The sun is big and powerful

   // Sun circle
   return groundFactor * sunCircle * sunFeathering * sunColor;
}

float GetHeightFogAmount( AtmosphereParameters params, vec3 worldPos, vec3 viewPos )
{
   const vec3 camToFrag = worldPos - viewPos;
   const float distance = length( camToFrag );
   const vec3 viewDir   = camToFrag / distance;

   // Density
   const float fogDensity = ( params.heightFog.x / params.heightFog.y ) *
                     exp( -viewPos.y * params.heightFog.y ) *
                     ( 1.0 - exp( -distance * viewDir.y * params.heightFog.y ) ) / viewDir.y;

   // We apply a feathering to the less dense parts of the fog.
   // As our previous calculated density decreases we want to increase the presence of this FBM noise. 
   // This is not physically based but is a convincing effect to imitate non-constant volumetric fog
   const float topFeather = SimplexFBM( worldPos.xz + ( params.time * 100.0 ), noiseParams );
   const float featherFactor = mix(topFeather, 1.0, fogDensity);

   const float fogAmount = fogDensity * featherFactor;

   return clamp(fogAmount * params.heightFog.z, 0.0, 1.0);
}

// ================================================================================================
void main()
{
   const ivec2 ssCoord = ivec2( gl_GlobalInvocationID.xy );
   const vec2 uv       = vec2( ssCoord + 0.5 ) / vec2( imageSize( colorImage ) );
   const float depth   = texture( depthSampler, uv ).r;

   // Constructing camera ray direction and world position
   // =============================================================================================
   // Ideally do one mat3 inverse view matrix multiplication and then add translation to
   // get world position so we don't multiply the inverse view matrix twice
   const vec4 ndc    = vec4( uv * 2.0 - 1.0, depth, 1.0 );  // UV [0,1] to NDC [-1,1]
   const vec4 rayEye = viewInfo.invProj * ndc;
   vec4 worldPos     = viewInfo.invView * rayEye;
   worldPos          = worldPos / worldPos.w;
   const vec3 rayDir = normalize( mat3( viewInfo.invView ) * rayEye.xyz );

   vec3 skyView       = vec3( 0.0 );
   vec3 fog           = vec3( 0.0 );
   const vec3 inColor = imageLoad( colorImage, ssCoord ).rgb;

   // Sky View
   // =============================================================================================
   if( depth == 0.0 )
   {
      // We only apply the sky view LUT where there is no data in the depth buffer
      const vec3 viewPosMM = getMMPosition( params.groundRadiusMM, viewInfo.viewPos.xyz );
      const float height   = viewPosMM.y;
      const vec3 sunDir    = -viewInfo.lightDir.xyz;

      const float beta =
          acos( sqrt( height * height - params.groundRadiusMM * params.groundRadiusMM ) / height );
      const float horizonAngle = PI - beta;

      const float altitudeAngle = horizonAngle - acos( dot( rayDir, up ) );

      // Angle 0 has the sun in the positive Z direction (looking towards -Z)
      const float minusCosTheta = -dot( rayDir, right );
      const float cosTheta      = dot( rayDir, forward );
      const float azimuthAngle  = atan( minusCosTheta, cosTheta ) + PI;

      // Making UVs, Y uses non-linear mapping formula from the paper
      const vec2 lookupUV = vec2(
          azimuthAngle / ( 2.0 * PI ),
          0.5 + 0.5 * sign( altitudeAngle ) * sqrt( abs( altitudeAngle ) / ( PI * 0.5 ) ) );

      skyView += texture( skyViewLUT, lookupUV ).rgb;

      // Adding sun circle
      // =============================================================================================
      const vec2 transmittanceUV = LUTParameterization(
          params.groundRadiusMM, params.atmosphereRadiusMM, sunDir, viewPosMM.xyz );
      const vec3 transmittance = texture( transmittanceLUT, transmittanceUV ).rgb;

      skyView += GetSunCircle( params, rayDir, sunDir, viewPosMM ) * transmittance;
   }
   else
   {
      // Aerial Perspective
      // =============================================================================================
      const float clipDistance = abs( params.farClip - params.nearClip );

      // Getting linear depth from depth buffer, then normalizing from 0 to 1
      float normDepth = params.nearClip * params.farClip /
                        ( params.farClip - depth * ( params.farClip - params.nearClip ) );
      normDepth /= clipDistance;

      const float w        = sqrt( normDepth );  // Squared distribution
      const float slice    = DepthToSlice( normDepth, textureSize( aerialPerspectiveLUT, 0 ).z );
      const float nearFade = min( slice + 1.0, 1.0 );
      const vec4 APLookup  = texture( aerialPerspectiveLUT, vec3( uv, w ) );

      const vec3 aerialPerspective = nearFade * APLookup.rgb;  // * APLookup.a;
      fog = mix( inColor, aerialPerspective, normDepth );

      if( params.heightFog.z > 0.0 )
      {
         const float heightFogAmount =
             GetHeightFogAmount( params, worldPos.xyz, viewInfo.viewPos.xyz );
         fog = mix( fog, APLookup.rgb, heightFogAmount );
      }
   }
   // Compiling and adjusting luminance
   // =============================================================================================
   vec3 luminance = skyView + fog;
   imageStore( colorImage, ssCoord, vec4( luminance, 1.0 ) );
}