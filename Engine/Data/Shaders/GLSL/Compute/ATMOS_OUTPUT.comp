#version 450

#include "ATMOS.h"
#include "../NOISE.h"

layout( local_size_x = 16, local_size_y = 16 ) in;

layout( push_constant ) uniform PUSH { AtmosphereParameters params; };

layout( set = 0, binding = 0 ) uniform ViewInfo
{
   mat4 invProj;
   mat4 invView;
   vec4 viewPos;
   vec4 lightDir;
}
viewInfo;

layout( set = 0, binding = 1 ) uniform sampler2D transmittanceLUT;
layout( set = 0, binding = 2 ) uniform sampler2D skyViewLUT;
layout( set = 0, binding = 3 ) uniform sampler3D aerialPerspectiveLUT;
layout( set = 0, binding = 4, rgba32f ) uniform image2D colorImage;
layout( set = 0, binding = 5 ) uniform sampler2D depthSampler;

NoiseParameters noiseParams = { 0.0, 1.0, 0.25, 0.003, 3.00, 1.0, false, false, 3 };

vec3 GetSunCircle( AtmosphereParameters params, vec3 rayDir, vec3 sunDir, vec3 viewPosMM )
{
   // If part of the sun is below ground level, some of it is hidden
   const float groundDist =
       rayIntersectSphere( viewPosMM, rayDir, spherePos, params.groundRadiusMM );
   const float groundFactor = groundDist >= 0.0 ? 0.0 : 1.0;  // Could early out

   const float cosThetaNoon = dot( sunDir, up );
   const float sunsetSize   = 0.9990;
   const float noonSize     = 0.9999;
   const float sunSize = mix( sunsetSize, noonSize, clamp( pow( cosThetaNoon, 0.3 ), 0.0, 1.0 ) );

   const float cosTheta  = dot( rayDir, sunDir );
   const float sunCircle = cosTheta > sunSize ? 1.0 : 0.0;

   const float x             = ( cosTheta - sunSize ) * 4000.0;
   const float sunFeathering = clamp( pow( x, 2 ), 0.0, 1.0 );
   const vec3 sunColor       = vec3( 2.0 );  // The sun is big and powerful

   // Sun circle
   return groundFactor * sunCircle * sunFeathering * sunColor;
}

vec3 GetHeightFog( AtmosphereParameters params, vec3 fogColor, vec3 worldPos, vec3 viewPos )
{
   const vec3 camToFrag = worldPos - viewPos;
   const float distance = length( camToFrag );
   const vec3 viewDir   = camToFrag / distance;

   float fogAmount = ( params.heightFog.x / params.heightFog.y ) *
                     exp( -viewPos.y * params.heightFog.y ) *
                     ( 1.0 - exp( -distance * viewDir.y * params.heightFog.y ) ) / viewDir.y;

   fogAmount *= SimplexFBM( worldPos.xz + ( params.time * 35.0 ), noiseParams );
   fogAmount = clamp( fogAmount, 0.0, 1.0 );

   return fogColor * fogAmount * params.heightFog.z;
}

// ================================================================================================
void main()
{
   const ivec2 ssCoord = ivec2( gl_GlobalInvocationID.xy );
   const vec2 uv       = vec2( ssCoord + 0.5 ) / vec2( imageSize( colorImage ) );
   const float depth   = texture( depthSampler, uv ).r;

   // Constructing camera ray direction and world position
   // =============================================================================================
   // Ideally do one mat3 inverse view matrix multiplication and then add translation to
   // get world position so we don't multiply the inverse view matrix twice
   const vec4 ndc    = vec4( uv * 2.0 - 1.0, depth, 1.0 );  // UV [0,1] to NDC [-1,1]
   const vec4 rayEye = viewInfo.invProj * ndc;
   vec4 worldPos     = viewInfo.invView * rayEye;
   worldPos          = worldPos / worldPos.w;
   const vec3 rayDir = normalize( mat3( viewInfo.invView ) * rayEye.xyz );

   vec3 skyView           = vec3( 0.0 );
   vec3 aerialPerspective = vec3( 0.0 );

   // Sky View
   // =============================================================================================
   if( depth == 0.0 )
   {
      // We only apply the sky view LUT where there is no data in the depth buffer
      const vec3 viewPosMM = getMMPosition( params.groundRadiusMM, viewInfo.viewPos.xyz );
      const float height   = viewPosMM.y;
      const vec3 sunDir    = -viewInfo.lightDir.xyz;

      const float beta =
          acos( sqrt( height * height - params.groundRadiusMM * params.groundRadiusMM ) / height );
      const float horizonAngle = PI - beta;

      const float altitudeAngle = horizonAngle - acos( dot( rayDir, up ) );

      // Angle 0 has the sun in the positive Z direction (looking towards -Z)
      const float minusCosTheta = -dot( rayDir, right );
      const float cosTheta      = dot( rayDir, forward );
      const float azimuthAngle  = atan( minusCosTheta, cosTheta ) + PI;

      // Making UVs, Y uses non-linear mapping formula from the paper
      const vec2 lookupUV = vec2(
          azimuthAngle / ( 2.0 * PI ),
          0.5 + 0.5 * sign( altitudeAngle ) * sqrt( abs( altitudeAngle ) / ( PI * 0.5 ) ) );

      skyView += texture( skyViewLUT, lookupUV ).rgb;

      // Adding sun circle
      // =============================================================================================
      const vec2 transmittanceUV = LUTParameterization(
          params.groundRadiusMM, params.atmosphereRadiusMM, sunDir, viewPosMM.xyz );
      const vec3 transmittance = texture( transmittanceLUT, transmittanceUV ).rgb;

      skyView += GetSunCircle( params, rayDir, sunDir, viewPosMM ) * transmittance;
   }
   else
   {
      // Aerial Perspective
      // =============================================================================================
      const float clipDistance = abs( params.farClip - params.nearClip );

      // Getting linear depth from depth buffer, then normalizing from 0 to 1
      float normDepth = params.nearClip * params.farClip /
                        ( params.farClip - depth * ( params.farClip - params.nearClip ) );
      normDepth /= clipDistance;

      const float w        = normDepth;  // Squared distribution
      const float slice    = DepthToSlice( normDepth, textureSize( aerialPerspectiveLUT, 0 ).z );
      const float nearFade = min( slice + 1.0, 1.0 );
      const vec4 APLookup  = texture( aerialPerspectiveLUT, vec3( uv, w ) );

      aerialPerspective += nearFade * APLookup.rgb * APLookup.a;

      aerialPerspective +=
          GetHeightFog( params, aerialPerspective, worldPos.xyz, viewInfo.viewPos.xyz );
   }

   // Compiling and adjusting luminance
   // =============================================================================================
   vec3 white_point = vec3( 1.08241, 0.96756, 0.95003 );
   float exposure   = 10.0;
   vec3 luminance   = skyView + aerialPerspective;
   luminance =
       pow( vec3( 1.0 ) - exp( -luminance.rgb / white_point * exposure ), vec3( 1.0 / 2.2 ) );

   const vec3 inColor = imageLoad( colorImage, ssCoord ).rgb;
   imageStore( colorImage, ssCoord, vec4( inColor.rgb + luminance, 1.0 ) );
}