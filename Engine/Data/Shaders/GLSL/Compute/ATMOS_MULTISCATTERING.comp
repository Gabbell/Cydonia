#version 450

#include "ATMOS.h"

layout( local_size_x = 16, local_size_y = 16 ) in;

layout( push_constant ) uniform PUSH { AtmosphereParameters params; };

layout( set = 0, binding = 0, rgba8 ) readonly uniform image2D transmittanceLUT;
layout( set = 0, binding = 1 ) writeonly uniform image2D multipleScatteringLUT;

// Constants
// ================================================================================================
const uint multipleScatteringSteps = 20;
const uint numSphereSamplesSqrt    = 8;  // 64 total samples
const uint numSphereSamples        = numSphereSamplesSqrt * numSphereSamplesSqrt;

// ================================================================================================

void main()
{
   const ivec2 ssCoord = ivec2( gl_GlobalInvocationID.xy );
   const vec2 uv       = vec2( ssCoord + 0.5 ) / vec2( imageSize( multipleScatteringLUT ) );
   const vec4 uvParameterization = inverseLUTParameterization( params, uv );

   const vec2 transmittanceDims = vec2( imageSize( transmittanceLUT ) );

   const vec3 sunDir = uvParameterization.xyz;
   const vec3 pos    = vec3( 0.0, uvParameterization.w, 0.0 );

   // Inverse of total number of hemisphere samples we'll be taking
   const float invNumSamples = 1.0 / numSphereSamples;

   vec3 luminanceTotal = vec3( 0.0 );  // L_2ndOrder
   vec3 fms            = vec3( 0.0 );

   // Calculating equation 5 and 7
   for( uint thetaStep = 0; thetaStep < numSphereSamplesSqrt; thetaStep++ )
   {
      for( uint phiStep = 0; phiStep < numSphereSamplesSqrt; phiStep++ )
      {
         const float curTheta = PI * ( thetaStep ) / numSphereSamplesSqrt;
         const float curPhi   = PI * ( phiStep ) / numSphereSamplesSqrt;
         const vec3 rayDir    = getDirFromSpherical( curTheta, curPhi );

         const float atmoDist =
             rayIntersectSphere( pos, rayDir, spherePos, params.atmosphereRadiusMM );
         const float groundDist =
             rayIntersectSphere( pos, rayDir, spherePos, params.groundRadiusMM );
         // ||p - x|| This should be distance to closest geometry
         const float tMax = groundDist > 0.0 ? groundDist : atmoDist;

         const float cosTheta      = dot( rayDir, sunDir );
         const float rayleighPhase = getRayleighPhase( cosTheta );
         const float miePhase      = getMiePhase( cosTheta );

         // Equation 8 from paper
         vec3 luminance       = vec3( 0.0 );
         vec3 luminanceFactor = vec3( 0.0 );
         vec3 transmittance   = vec3( 1.0 );
         float t              = 0.0;
         for( uint step = 0; step < multipleScatteringSteps; step++ )
         {
            const float newT = step * ( tMax / multipleScatteringSteps );
            const float dt   = newT - t;

            t = newT;

            const vec3 newPos = pos + t * rayDir;

            vec3 rayleighScattering;
            float mieScattering;
            vec3 extinction;
            getScatteringValues( newPos, params, rayleighScattering, mieScattering, extinction );

            const vec3 sampleTransmittance = exp( -dt * extinction );

            const vec3 scatteringNoPhase = rayleighScattering + mieScattering;
            const vec3 scatteringF =
                ( scatteringNoPhase - ( scatteringNoPhase * sampleTransmittance ) ) / extinction;

            const ivec2 lookupCoord =
                ivec2( round( LUTParameterization( params, sunDir, newPos ) * transmittanceDims ) );
            const vec3 lookupTransmittance = imageLoad( transmittanceLUT, lookupCoord ).rgb;

            const vec3 rayleighInScattering = rayleighScattering * rayleighPhase;
            const float mieInScattering     = mieScattering * miePhase;
            const vec3 inScattering =
                ( rayleighInScattering + mieInScattering ) * lookupTransmittance;

            const vec3 scatteringIntegral =
                ( inScattering - ( inScattering * sampleTransmittance ) ) / extinction;

            luminanceFactor += ( scatteringF * transmittance );
            luminance += ( scatteringIntegral * transmittance );
            transmittance *= sampleTransmittance;
         }

         if( groundDist > 0.0 && dot( pos, sunDir ) > 0.0 )
         {
            vec3 hitPos = pos + groundDist * rayDir;
            hitPos      = normalize( hitPos ) * params.groundRadiusMM;

            const ivec2 lookupCoord =
                ivec2( round( LUTParameterization( params, sunDir, hitPos ) * transmittanceDims ) );
            const vec3 lookupTransmittance = imageLoad( transmittanceLUT, lookupCoord ).rgb;

            luminance += transmittance * groundAlbedo * lookupTransmittance;
         }

         fms += luminanceFactor;
         luminanceTotal += luminance;
      }
   }

   fms *= invNumSamples;
   luminanceTotal *= invNumSamples;

   // Calculating equation 10 (Psi)
   const vec3 Psi_ms = luminanceTotal / ( 1.0 - fms );

   imageStore( multipleScatteringLUT, ssCoord, vec4( Psi_ms, 1.0 ) );
}