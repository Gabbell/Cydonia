#version 450

#include "ATMOS.h"

layout( local_size_x = 16, local_size_y = 16 ) in;

layout( push_constant ) uniform PUSH { AtmosphereParameters params; };

layout( set = 0, binding = 0 ) uniform ViewInfo
{
   mat4 invProj;
   mat4 invView;
   vec4 viewPos;
   vec4 lightDir;
}
viewInfo;

layout( set = 0, binding = 1 ) uniform sampler2D transmittanceLUT;
layout( set = 0, binding = 2 ) uniform sampler2D multiScatteringLUT;
layout( set = 0, binding = 3 ) writeonly uniform image2D skyViewLUT;

// Constants
// ================================================================================================
const uint numScatteringSteps = 32;

// ================================================================================================
void main()
{
   const ivec2 ssCoord = ivec2( gl_GlobalInvocationID.xy );
   const vec2 uv       = vec2( ssCoord + 0.5 ) / vec2( imageSize( skyViewLUT ) );

   // Adjusting current view position to be within the same scale (megameters)
   const vec3 viewPos = getMMPosition( params, viewInfo.viewPos.xyz );
   const float height = length( viewPos );

   // Ranges to match LUT from the paper
   const float longitudeAngle = ( uv.x - 0.5 ) * 2.0 * PI;  // Longitude from 0 to 2PI

   const float beta =
       acos( sqrt( height * height - params.groundRadiusMM * params.groundRadiusMM ) / height );
   const float horizonAngle = beta - ( 0.5 * PI );

   // Non-linear mapping from the paper
   float altitudeAngle = 0.0;  // Altitude from -PI/2 to PI/2
   if( uv.y < 0.5 )
   {
      float coord = 1.0 - 2.0 * uv.y;
      coord *= -coord;
      altitudeAngle = coord * 0.5 * PI + horizonAngle;
   }
   else
   {
      float coord = 2.0 * uv.y - 1.0;
      coord *= coord;
      altitudeAngle = coord * 0.5 * PI + horizonAngle;
   }

   const vec3 sunDir = -viewInfo.lightDir.xyz;
   const vec3 rayDir = vec3(
       cos( altitudeAngle ) * sin( longitudeAngle ),
       sin( altitudeAngle ),
       cos( longitudeAngle ) * -cos( altitudeAngle ) );
   const vec3 spherePos = vec3( 0.0, 0.0, 0.0 );

   const float atmoDist =
       rayIntersectSphere( viewPos.xyz, rayDir, spherePos, params.atmosphereRadiusMM );
   const float groundDist =
       rayIntersectSphere( viewPos.xyz, rayDir, spherePos, params.groundRadiusMM );

   // Start raymarching/integrating
   const float tMax = groundDist < 0.0 ? atmoDist : groundDist;

   const float cosTheta = dot( rayDir, sunDir );

   const float rayleighPhase = getRayleighPhase( -cosTheta );
   const float miePhase      = getMiePhase( -cosTheta );

   vec3 luminance     = vec3( 0.0 );
   vec3 transmittance = vec3( 1.0 );
   float t            = 0.0;
   for( uint step = 0; step < numScatteringSteps; step++ )
   {
      const float newT = ( step + 0.1 ) * ( tMax / numScatteringSteps );
      const float dt   = newT - t;

      t = newT;

      const vec3 newPos = viewPos.xyz + t * rayDir;

      vec3 rayleighScattering;
      float mieScattering;
      vec3 extinction;
      getScatteringValues( newPos, params, rayleighScattering, mieScattering, extinction );

      const vec3 sampleTransmittance = exp( -dt * extinction );

      const vec2 lookupUV = LUTParameterization( params, sunDir, newPos );

      const vec3 lookupTransmittance = texture( transmittanceLUT, lookupUV ).rgb;
      const vec3 Psi_ms              = texture( multiScatteringLUT, lookupUV ).rgb;

      const vec3 rayleighInScattering =
          rayleighScattering * ( rayleighPhase * lookupTransmittance + Psi_ms );
      const vec3 mieInScattering = mieScattering * ( miePhase * lookupTransmittance + Psi_ms );
      const vec3 inScattering    = ( rayleighInScattering + mieInScattering );

      // Integrated scattering within path segment.
      const vec3 scatteringIntegral =
          ( inScattering - inScattering * sampleTransmittance ) / extinction;

      luminance += ( scatteringIntegral * transmittance );
      transmittance *= sampleTransmittance;
   }

   imageStore( skyViewLUT, ssCoord, vec4( luminance, 1.0 ) );
}