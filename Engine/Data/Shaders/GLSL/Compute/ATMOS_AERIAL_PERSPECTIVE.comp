#version 450

#include "../ATMOS.h"
#include "../VIEW.h"
#include "../COLOR.h"
#include "../LIGHTING.h"
#include "../SHADOW.h"

layout( local_size_x = 16, local_size_y = 16, local_size_z = 1 ) in;

layout( push_constant ) uniform PUSH { AtmosphereParameters params; };

layout( set = 0, binding = 0 ) uniform Views { View views[MAX_VIEWS]; };
layout( set = 0, binding = 1 ) uniform InverseViews { InverseView inverseViews[MAX_VIEWS]; };
layout( set = 0, binding = 2 ) uniform Lights { Light lights[MAX_LIGHTS]; };

layout( set = 0, binding = 3 ) uniform sampler2D transmittanceLUT;
layout( set = 0, binding = 4 ) uniform sampler2D multiScatteringLUT;

layout( set = 0, binding = 5 ) writeonly uniform image3D aerialPerspectiveLUT;

// Constants
// ================================================================================================
const uint numScatteringSteps = 32;
const float stepContribution  = 1.0 / numScatteringSteps;

const float maxDistanceMM = 0.032;  // 32KM

// ================================================================================================
void main()
{
   const ivec3 ssCoord = ivec3( gl_GlobalInvocationID.xyz );
   const ivec3 LUTsize = imageSize( aerialPerspectiveLUT );
   const float distanceMM =
       SliceToDistanceMM( ssCoord.z, maxDistanceMM, LUTsize.z );
   const vec2 uv = ( ssCoord.xy + 0.5 ) / LUTsize.xy;

   const InverseView inverseMainView = inverseViews[0];
   const View sunView                = views[1];
   const Light sunLight              = lights[0];

   // Constructing camera ray direction in world space
   // =============================================================================================
   const vec4 ndcCoord = vec4( ( uv * 2.0 ) - 1.0, -1.0, 1.0 );  // UV [0,1] to NDC [-1,1]
   vec4 rayEye         = inverseMainView.invProjMat * ndcCoord;
   const vec3 rayDir   = normalize( mat3( inverseMainView.invViewMat ) * rayEye.xyz );

   // Adjusting current view position to be within the same scale (megameters)
   const vec3 viewPosMM = getMMPosition( params.groundRadiusMM, inverseMainView.pos.xyz );
   const vec3 sunDir    = -sunLight.direction.xyz;

   // Start raymarching/integrating
   const float tMax = distanceMM;

   const float cosTheta = dot( rayDir, sunDir );

   const float rayleighPhase = getRayleighPhase( cosTheta );
   const float miePhase      = getMiePhase( params.miePhase, cosTheta );

   vec3 luminance          = vec3( 0.0 );
   float meanTransmittance = 0.0;
   vec3 transmittance      = vec3( 1.0 );
   float t                 = 0.0;
   for( uint step = 0; step < numScatteringSteps; step++ )
   {
      const float newT = ( step + 0.5 ) * ( tMax / numScatteringSteps );
      const float dt   = newT - t;

      t = newT;

      const vec3 newPos = viewPosMM.xyz + t * rayDir;

      vec3 rayleighScattering;
      vec3 mieScattering;
      vec3 extinction;
      getScatteringValues( newPos, params, rayleighScattering, mieScattering, extinction );

      const vec3 sampleTransmittance = exp( -dt * extinction );

      const vec2 lookupUV =
          LUTParameterization( params.groundRadiusMM, params.atmosphereRadiusMM, sunDir, newPos );

      const vec3 lookupTransmittance = texture( transmittanceLUT, lookupUV ).rgb;
      const vec3 Psi_ms              = texture( multiScatteringLUT, lookupUV ).rgb;

      const vec3 rayleighInScattering =
          rayleighScattering * ( rayleighPhase * lookupTransmittance + Psi_ms );
      const vec3 mieInScattering = mieScattering * ( miePhase * lookupTransmittance + Psi_ms );
      const vec3 inScattering    = ( rayleighInScattering + mieInScattering );

      // Integrated scattering within path segment.
      const vec3 scatteringIntegral =
          ( inScattering - inScattering * sampleTransmittance ) / extinction;

      luminance += ( scatteringIntegral * transmittance );

      meanTransmittance +=
          ( ( transmittance.r + transmittance.g + transmittance.b ) / 3.0 ) * stepContribution;

      transmittance *= sampleTransmittance;
   }

   luminance = ColorCorrect( luminance, 20 );

   imageStore( aerialPerspectiveLUT, ssCoord, vec4( luminance, meanTransmittance ) );
}